<!DOCTYPE html>
<!-- This program is free software. It comes without any warranty, to
 * the extent permitted by applicable law. You can redistribute it
 * and/or modify it under the terms of the Do What The Fuck You Want
 * To Public License, Version 2, as published by Sam Hocevar. See
 * http://sam.zoy.org/wtfpl/COPYING for more details. -->
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Tron circles</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width; initial-scale=1.0;">
        <meta name="author" content="Peter Dragun">
        <meta name="description" content="Tron Legacy circles generated by javascript (and canvas)">
        <style type="text/css">
            body {
                background-color: black;
                text-align: center;
                margin: 0;
                padding: 0;                
            }
            h1 {
                font-size: large;
            }            
            h1, p, a, a:hover {
                color: white;
            }
            div {
                padding: 0;
                margin: 0;
            }
            noscript {
                color: red;
            }
            header, footer {
                display: block;
                width: 100%;
            }
           .inner {
                display: inline-block; /*center inner div*/
            }
            footer p {
                width: 100px;
                float: left;
            }
        </style>
    </head>
    <body>
        <header>
            <h1>Tron circles</h1>
            <p>Refresh your browser to generate new circles.</p>
        </header>
        <div id="draw"><noscript>Please turn on Javascript or use another web browser (Firefox, Chrome, Opera/Mobile).</noscript></div>
        <footer>
            <div class="inner">
                <p><b>FPS: </b><span id="fps"></span></p>
                <p><a href="https://github.com/pdragun/tron-circles"><b>About</b></a></p>
                <p><a href="https://github.com/pdragun"><b>Author</b></a></p>
            </div>
        </footer>
        <script type="text/javascript">
            //<![CDATA[

            // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
            // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
            // requestAnimationFrame polyfill by Erik Möller
            // fixes from Paul Irish and Tino Zijdel
            (function() {
                var lastTime = 0;
                var vendors = ['ms', 'moz', 'webkit', 'o'];
                for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
                    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
                    window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] 
                        || window[vendors[x]+'CancelRequestAnimationFrame'];
                }
 
                if (!window.requestAnimationFrame)
                    window.requestAnimationFrame = function(callback, element) {
                        var currTime = new Date().getTime();
                        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                        var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
                        timeToCall);
                        lastTime = currTime + timeToCall;
                        return id;
                    };
 
                if (!window.cancelAnimationFrame)
                    window.cancelAnimationFrame = function(id) {
                        clearTimeout(id);
                    };
            }());
            
            //Main init object
            //Run at the begining
            var Init = {
                max_radius: 0,
                centerX: 0,
                centerY: 0,
                
                init: function(){
                    var min_circles = 3; //minimumm circles
                    var max_circles = 10; //maximum circles
                    var min_line_width = 5; //minimum circle line width
                    var max_line_width = 25; //maximum circle line width
                    var min_radius = 5; //minimal circle radius
                    var color_scheme = [];
                    color_scheme[0] = [];
                    color_scheme[0][0] = '1,198,241';
                    color_scheme[0][1] = '0,13,16';
                    color_scheme[1] = [];
                    color_scheme[1][0] = '3,198,190';
                    color_scheme[1][1] = '0,7,2';
                    color_scheme[2] = [];
                    color_scheme[2][0] = '0,255,246';
                    color_scheme[2][1] = '0,68,49';
                    color_scheme[3] = [];
                    color_scheme[3][0] = '0,254,255';
                    color_scheme[3][1] = '0,29,39';
                    
                    //Check size of browser
                    var header_height = document.getElementsByTagName('header')[0].offsetHeight;
                    var footer_height = document.getElementsByTagName('footer')[0].offsetHeight;
                    
                    //Check size for canvas
                    Circles.height = window.innerHeight - (header_height + footer_height + 50); //random value, because it is not so easy check margin/padding for all inner objects (div,h1,p ...) - without jQuery/..
                    Circles.width = window.innerWidth;

                    //Create canvas element
                    Circles.init();

                    this.max_radius = Circles.width >= Circles.height ? Circles.height/2 : Circles.width/2;
                    this.centerX = Math.round(Circles.width / 2);
                    this.centerY = Math.round(Circles.height / 2);

                    var circle_numbers = Math.floor(Math.random() * max_circles) + min_circles;
                    
                    //Uncoment line below, if you want draw only one circle
                    //circle_numbers = 0;
                    for (var i = 0; i <= circle_numbers; i++ ) {

                        var temp_properties = new Properties();
                        temp_properties.number = i;
                        
                        temp_properties.lineWidth = Math.floor(Math.random() * max_line_width) + min_line_width;
                        
                        temp_properties.radius = this.findRadius(Circles.getCircles(), min_radius, this.max_radius, temp_properties.lineWidth, 0);
                        if(temp_properties.radius === false) continue; //can not find radius for this circle (because of collision), skip it
                        
                        temp_properties.startAngle = Math.round(Math.random() * 360); //random degree from 0° to 360°
                        temp_properties.endAngle = Math.round(Math.random() * 360); //random degree from 0° to 360°
                        temp_properties.counterclockwise = Math.round(Math.random() * 1); //random boolean 1 = true or 0 = false
                        
                        temp_properties.colorScheme = color_scheme[Math.round(Math.random() * 3)]; //random value from list of schemes (it is array with 4 keys (0,1,2,3))


                        //rotation start
                        temp_properties.rotation = Math.round(Math.random() * 10) + 1; //random degree 1° - 10°
                        var rotation_direction = Math.round(Math.random() * 1)? 1: -1; //random direction 1 or -1
                        temp_properties.rotation = rotation_direction * temp_properties.rotation; //final rotation, with degree and direction
                        
                        temp_properties.rotateToAngle = temp_properties.startAngle + temp_properties.rotation;
                        if(temp_properties.rotateToAngle < 0 || temp_properties.rotateToAngle > 360) {
                            temp_properties.rotateToAngle = Math.abs(360 - Math.abs(temp_properties.rotateToAngle));
                        }
                        //rotation end

                        //We have enough data, create new circle
                        var NewCircle = new Circle(temp_properties);
                        Circles.addCircle(NewCircle)                        
                    }

                    //Init all circles
                    var all_circles = Circles.getCircles();
                    for (var key in all_circles) {
                        all_circles[key].init();
                    }
                },
                findRadius: function(all_circles, min_radius, max_radius, line_width, deep){
                    
                    //Check if we are not too deep in recursion, if yes return false and 'delete' circle (TODO: change line_width and count again)
                    deep++;
                    if(deep === 10) return false;
                    
                    //TODO: rename this temporary variables!!
                    var circle_radius = Math.floor(Math.random() * max_radius) + min_radius;  //'normal' radius
                    
                    var min_line_radius = circle_radius - Math.round(line_width / 2) - 1; //radius - 1/2 line width = min_line_radius - need to check collision with other circles
                    var max_line_radius = circle_radius + Math.round(line_width / 2) + 1; //radius + 1/2 line width = max_line_radius - need to check collision with other circles

                    //If no circle has been set yet, return current radius (= no collision)
                    if(all_circles.length < 1){
                        return circle_radius;
                    }
                    
                    //We have already some circles, need to check if collision or not
                    var collision_radius, collision_min_line_radius, collision_max_line_radius;
                    for(var key in all_circles) {
                        collision_radius = all_circles[key].properties.radius;  //'normal' radius
                        
                        collision_min_line_radius = collision_radius - Math.round(all_circles[key].properties.lineWidth / 2);
                        collision_max_line_radius = collision_radius + Math.round(all_circles[key].properties.lineWidth / 2);

                        //if true, we have collision
                        if(   (max_line_radius >= collision_max_line_radius && min_line_radius < collision_max_line_radius && min_line_radius > collision_min_line_radius)
                            || (max_line_radius <= collision_max_line_radius && max_line_radius >= collision_min_line_radius && min_line_radius < collision_min_line_radius)
                            ){
                            //recursion
                            return this.findRadius(all_circles, min_radius, max_radius, line_width, deep);
                        }
                    }
                    //no collision
                    return circle_radius;
                }
            }


            //Contstructor of Properties object
            //Hold basic properties for circle
            function Properties() {
                this.number = 0; //int, nubmer e.g. 1,2, ...13
                this.startAngle = 0; //int, in degrees [°]
                this.endAngle = 0;  //int, in degrees [°]
                this.radius = 0;  //int, in pixels
                this.lineWidth = 1;  //int, in pixels, at least 1px
                this.rotation = 1; //int, in degrees, if negative move counterclockwise, default = 1;
                this.rotateToAngle = 0; //int, in next draw circle, rotate to this angle, default = 0;
                this.counterclockwise = false; //boolean, false is default (oposit of normal clockwise direction:)
                this.colorScheme = []; //array, color scheme in RGB values, separated by comma
            }
            
            
            //Constructor of object Circle
            //Each circle has it's own object
            function Circle(properties){
                this.properties = properties; //see function/object Properties for more info
                this.scheme = null; //color scheme
            }
            Circle.prototype.animate = function(){

                Circles.ctx.save();
                Circles.ctx.translate(Init.centerX, Init.centerY); //move canvas to newer position
                Circles.ctx.rotate(this.properties.rotateToAngle * Math.PI/180); //rotate it, from degree to radian
                Circles.ctx.translate(-Init.centerX, -Init.centerY); //move canvas back, so it will be rotated around center
 
                
                //TODO code duplicity with Circle.init(), fix it, fix it
                for (var key in this.scheme) {
                    key = parseInt(key);
            
                    if( typeof(this.scheme[key+1]) == 'undefined') break;

                    Circles.ctx.beginPath();
                    Circles.ctx.lineWidth = this.properties.lineWidth;
                    Circles.ctx.strokeStyle = this.scheme[key]['rgb'];
                    Circles.ctx.arc(
                        Init.centerX,
                        Init.centerY,
                        this.properties.radius,
                        typeof(this.scheme[key-1]) === 'undefined'? this.scheme[key]['radian']:this.scheme[key-1]['radian'],
                        this.scheme[key+1]['radian'],
                        this.properties.counterclockwise
                    );

                    Circles.ctx.stroke();
                    Circles.ctx.closePath()
                }

                Circles.ctx.restore();
                
                //Count rotate angle for next frame
                this.properties.rotateToAngle = this.properties.rotateToAngle + this.properties.rotation;
                if(this.properties.rotateToAngle < 0 || this.properties.rotateToAngle > 360) {
                    this.properties.rotateToAngle = Math.abs(360 - Math.abs(this.properties.rotateToAngle));
                }

                return true;
            }
            Circle.prototype.setColorScheme = function(scheme){
                this.scheme = scheme;
                return true;
            }
            //method to set color for each peace
            //this method run only once for each circe
            Circle.prototype.countColorScheme = function() {
                
                var all_drawable_pieces = 0;
                //Count number of degrees between start angle and end angle
                if (this.properties.counterclockwise === 0) { //arc is clockwise
                    
                    if( this.properties.startAngle > this.properties.endAngle ) { //we are going through 360°/0°
                        var temp_degree1, temp_degree2;
                        temp_degree1 = 360 - this.properties.startAngle;
                        temp_degree2 = this.properties.endAngle;
                        all_drawable_pieces = temp_degree1 + temp_degree2;
                    } else {
                        all_drawable_pieces = this.properties.endAngle - this.properties.startAngle;
                    }
                    
                } else { //arc is anticlockwise or counterclockwise
                    
                    if( this.properties.startAngle > this.properties.endAngle ) {
                        all_drawable_pieces = this.properties.startAngle - this.properties.endAngle;
                    } else { //we are going through 360°/0°
                        var temp_degree1, temp_degree2;
                        temp_degree1 = this.properties.startAngle;
                        temp_degree2 = 360 - this.properties.endAngle;
                        all_drawable_pieces = temp_degree1 + temp_degree2;
                    }                    
                }
                all_drawable_pieces = all_drawable_pieces - 1;
                
                var temp_scheme = [];
                temp_scheme['begin'] = [];
                temp_scheme['end'] = [];
                
                //TODO: add random choice for begin and end color - take random color from color range!
                
                //Set which color will begin and which end
                var splited_scheme =  this.properties.colorScheme[0].split(',');
                temp_scheme['begin']['r'] = parseInt(splited_scheme[0]);
                temp_scheme['begin']['g'] = parseInt(splited_scheme[1]);
                temp_scheme['begin']['b'] = parseInt(splited_scheme[2]);

                splited_scheme = this.properties.colorScheme[1].split(',');
                temp_scheme['end']['r'] = parseInt(splited_scheme[0]);
                temp_scheme['end']['g'] = parseInt(splited_scheme[1]);
                temp_scheme['end']['b'] = parseInt(splited_scheme[2]);
                
                if(Math.round(Math.random() * 1) === 0) {   //with ratio 50/50 change begin color to end color (or not)
                    splited_scheme = this.properties.colorScheme[1].split(',');
                    temp_scheme['begin']['r'] = parseInt(splited_scheme[0]);
                    temp_scheme['begin']['g'] = parseInt(splited_scheme[1]);
                    temp_scheme['begin']['b'] = parseInt(splited_scheme[2]);

                    splited_scheme = this.properties.colorScheme[0].split(',');
                    temp_scheme['end']['r'] = parseInt(splited_scheme[0]);
                    temp_scheme['end']['g'] = parseInt(splited_scheme[1]);
                    temp_scheme['end']['b'] = parseInt(splited_scheme[2]);
                }

                //ratio between begin begin color and end color and number of drawable pieces
                //(e.g. begin color is 10 (rgb value) and end color is 20 and drawable pieces is 5 so
                //the first piece will have color value 12, next 14, 16, 18 and 20
                var ratio_r = this.countColorRatioAndDirection(temp_scheme['begin']['r'], temp_scheme['end']['r'], all_drawable_pieces);
                var ratio_g = this.countColorRatioAndDirection(temp_scheme['begin']['g'], temp_scheme['end']['g'], all_drawable_pieces);
                var ratio_b = this.countColorRatioAndDirection(temp_scheme['begin']['b'], temp_scheme['end']['b'], all_drawable_pieces);

                //set color for each piece
                var color_scheme = [];
                color_scheme[0] = [];
                //first piece
                color_scheme[0]['rgb'] = 'rgb('+temp_scheme['begin']['r']+','+temp_scheme['begin']['g']+','+temp_scheme['begin']['b']+')';
                color_scheme[0]['radian'] = this.properties.startAngle * Math.PI / 180;
                
                var radian_direction = this.properties.counterclockwise === 1? -1 : 1;
                var angle = this.properties.startAngle;
                for (var i = 1; i <= all_drawable_pieces; i++){
                    angle += radian_direction;
                   
                    color_scheme[i] = [];
                    //other pieces
                    color_scheme[i]['rgb']  = 'rgb('+ Math.round(temp_scheme['begin']['r'] + (ratio_r * i))+','+
                                            +Math.round(temp_scheme['begin']['g'] + (ratio_g * i))+','+
                                            +Math.round(temp_scheme['begin']['b'] + (ratio_b * i))+')';
                   
                    if (angle <= 0) {
                        angle = 359;
                    } else if (angle > 360) {
                        angle = 1;
                    }
                    color_scheme[i]['radian'] = angle * Math.PI/180;
                }

                this.setColorScheme(color_scheme);
                return true;
            }
            Circle.prototype.countColorRatioAndDirection = function(begin_color, end_color, degrees){
                
                var ratio = Math.abs(begin_color - end_color) / degrees;
                return begin_color >= end_color ? ratio * -1 : ratio;
                
            }
            Circle.prototype.init = function(){
                
                this.countColorScheme();
                
                for (var key in this.scheme) {
                    key = parseInt(key);
            
                    if( typeof(this.scheme[key+1]) == 'undefined') break;

                    // draw a sector
                    Circles.ctx.beginPath();
                    Circles.ctx.arc(
                        Init.centerX,
                        Init.centerY,
                        this.properties.radius,
                        typeof(this.scheme[key-1]) === 'undefined'? this.scheme[key]['radian']:this.scheme[key-1]['radian'],
                        this.scheme[key+1]['radian'],
                        this.properties.counterclockwise
                    );
                    
                    Circles.ctx.closePath();

                    //stroke a sector
                    Circles.ctx.lineWidth = this.properties.lineWidth;
                    Circles.ctx.strokeStyle = this.scheme[key]['rgb'];
                    Circles.ctx.stroke();
                }
            }
            
            //Circle object
            //Hold reference to all Circle objects
            var Circles = {
                circles_collection: [], //array with all circle objects
                ctx: null, //reference to canvas object
                width: 0, //size of canvas in px [int]
                height: 0, //size of canvas in px [int]

                //collect all circle objects in array, insert circle object
                addCircle: function(circle){
                    this.circles_collection.push(circle);
                    return true;
                },
                //return all existing circle objects in array
                getCircles: function(){
                    return this.circles_collection;
                },
                //create canvas element and hold references to it
                init: function(){

                    var canvas_div = document.createElement('div');

                    var canvas_html = '<canvas id=\"playground_canvas\" width=\"'+this.width+'\" height=\"'+this.height+'\">Your browser doesn\'t support canvas element. Please choose one of the newest version of modern browsers: Firefox, Chrome or Opera.<\/canvas>';
                    canvas_div.innerHTML = canvas_html;

                    document.getElementById('draw').appendChild(canvas_div);
                    var canvas = document.getElementById('playground_canvas');
                    
                    this.ctx = canvas.getContext('2d');
                }
            }
            
            //Statistics
            //inspired with: http://active.tutsplus.com/tutorials/animation/html5-canvas-optimization-a-practical-example/
            //TODO rewrite this quick & dirty solution
            var frameCount = 0;
            var logs = document.getElementById('fps');
            function getStats(){
                logs.innerHTML = frameCount;
                frameCount = 0;
                setTimeout( getStats, 1000 );
            }
            
            //Init
            Init.init();
            
            //run animations
            //by: http://paulirish.com/2011/requestanimationframe-for-smart-animating/
            (function animloop(){
                frameCount++; //for statistics
                
                //clear canvas:
                Circles.ctx.clearRect(0, 0, Circles.width, Circles.height);
                
                var all_circles = Circles.getCircles();
                for (var key in all_circles) {
                    all_circles[key].animate();
                }
                window.requestAnimationFrame(animloop);
            })();
            
            //run statistics:
            getStats();
            //]]>
        </script>
    </body>
</html>
