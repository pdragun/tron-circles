<!DOCTYPE html>
<!-- This program is free software. It comes without any warranty, to
 * the extent permitted by applicable law. You can redistribute it
 * and/or modify it under the terms of the Do What The Fuck You Want
 * To Public License, Version 2, as published by Sam Hocevar. See
 * http://sam.zoy.org/wtfpl/COPYING for more details. -->
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Tron circles</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width; initial-scale=1.0;">
        <meta name="author" content="Peter Dragun">
        <meta name="description" content="Nice animation in 'Tron legacy' style. Rotating circles with different sizes generated by Javascprit. Using HTML5, canvas.">
        <!--[if IE]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
        <style type="text/css">
            body {
                background-color: black;
                text-align: center;
                margin: 0;
                padding: 0;                
            }
            h1 {
                font-size: large;
            }            
            h1, p, a, a:hover {
                color: white;
            }
            div {
                padding: 0;
                margin: 0;
            }
            noscript {
                color: red;
            }
            #header, #footer {
                display: block;
                width: 100%;
            }
            #header {
                height: 90px;
            }
            #footer {
                height: 40px;
            }
           .inner {
                display: inline-block; /*center inner div*/
            }
            #footer p {
                width: 100px;
                float: left;
                margin: 5px 0;
            }
        </style>
    </head>
    <body>
        <header id="header">
            <h1>Tron circles</h1>
            <p>Refresh your browser to generate new circles.</p>
        </header><!-- #header-->
        <div id="draw"><noscript>Please turn on Javascript or use another web browser (Firefox, Chrome, Opera/Mobile).</noscript></div>
        <footer id="footer">
            <div class="inner">
                <p><b>FPS: </b><span id="fps"></span></p>
                <p><a href="https://github.com/pdragun/tron-circles"><b>About</b></a></p>
                <p><a href="https://github.com/pdragun"><b>Author</b></a></p>
            </div>
        </footer><!-- #footer -->
        <script type="text/javascript">
            //<![CDATA[

            //Main init object
            //Run at the begining
            var Init = {
                no_canvas_support: 'Your browser doesn\'t support canvas element. Please choose one of the newest version of modern browsers: Firefox, Chrome or Opera.',
                init: function(){
                    var min_circles = 3; //minimumm circles
                    var max_circles = 10; //maximum circles
                    var min_line_width = 5; //minimum circle line width
                    var max_line_width = 25; //maximum circle line width
                    var min_radius = 5; //minimal circle radius
                    var color_scheme = [];
                    color_scheme[0] = [];
                    color_scheme[0][0] = '1,198,241';
                    color_scheme[0][1] = '0,13,16';
                    color_scheme[1] = [];
                    color_scheme[1][0] = '3,198,190';
                    color_scheme[1][1] = '0,7,2';
                    color_scheme[2] = [];
                    color_scheme[2][0] = '0,255,246';
                    color_scheme[2][1] = '0,68,49';
                    color_scheme[3] = [];
                    color_scheme[3][0] = '0,254,255';
                    color_scheme[3][1] = '0,29,39';
                    
                    //Calculate canvas size based on browser widht/height and header/footer width/height
                    var header_height = document.getElementById('header').offsetHeight;
                    var footer_height = document.getElementById('footer').offsetHeight;

                    //Set canvas size
                    Playground.height = window.innerHeight - (header_height + footer_height + 100); //+random value, because window.innerHeight always returns bigger value in FF dunno why?
                    Playground.width = window.innerWidth;
                    
                    if ( Playground.height > Playground.width) {
                        Playground.height = Playground.width;
                    } else {
                        Playground.width = Playground.height;
                    }

                    //Create canvas element
                    Circles.init();

                    Playground.max_radius = Playground.width >= Playground.height ? Playground.height/2 : Playground.width/2;
                    Playground.center_x = Math.round(Playground.width / 2);
                    Playground.center_y = Math.round(Playground.height / 2);

                    var circle_numbers = Math.floor(Math.random() * max_circles) + min_circles;
                    
                    //Uncoment line below, if you want draw only one circle
                    //circle_numbers = 0;
                    for (var i = 0; i <= circle_numbers; i++ ) {

                        var temp_properties = new Properties();
                        temp_properties.number = i;
                        
                        temp_properties.lineWidth = Math.floor(Math.random() * max_line_width) + min_line_width;
                        
                        temp_properties.radius = Circles.findRadius(Circles.getCircles(), min_radius, Playground.max_radius, temp_properties.lineWidth, 0);
                        if(temp_properties.radius === false) continue; //can not find radius for this circle (because of collision), skip it
                        
                        temp_properties.startAngle = Math.round(Math.random() * 360); //random degree from 0° to 360°
                        temp_properties.endAngle = Math.round(Math.random() * 360); //random degree from 0° to 360°
                        temp_properties.counterclockwise = Math.round(Math.random() * 1); //random boolean 1 = true or 0 = false
                        
                        temp_properties.colorScheme = color_scheme[Math.round(Math.random() * 3)]; //random value from list of schemes (it is array with 4 keys (0,1,2,3))


                        //rotation start
                        temp_properties.rotation = Math.round(Math.random() * 10) + 1; //random degree 1° - 10°
                        var rotation_direction = Math.round(Math.random() * 1)? 1: -1; //random direction 1 or -1
                        temp_properties.rotation = rotation_direction * temp_properties.rotation; //final rotation, with degree and direction
                        
                        temp_properties.rotateToAngle = temp_properties.startAngle + temp_properties.rotation;
                        if(temp_properties.rotateToAngle < 0 || temp_properties.rotateToAngle > 360) {
                            temp_properties.rotateToAngle = Math.abs(360 - Math.abs(temp_properties.rotateToAngle));
                        }
                        //rotation end

                        //We have enough data, create new circle
                        var NewCircle = new Circle(temp_properties);
                        Circles.addCircle(NewCircle)                        
                    }

                    //Init all circles
                    var all_circles = Circles.getCircles();
                    for (var key in all_circles) {
                        all_circles[key].init();
                    }
                    
                    //Init and start animation
                    Animation.init();
                    Animation.setObjToAnimate(Statistics, Circles);
                    Animation.start();
                    
                    //Init Statistics
                    var html_fps = document.getElementById('fps');
                    Statistics.init(html_fps);
                    Statistics.start();
                }
            }


            //Obj hold basic properties for canvas (not canvas itself)
            var Playground = {
                center_x: 0,
                center_y: 0,
                width: 0, // playground width [int] px
                height: 0, // playground height [int] px
                max_radius: 0, //maximal radius for the biggest circle [int] px
            }


            //Contstructor of Properties object
            //Hold basic properties for circle
            function Properties() {
                this.number = 0; //int, nubmer e.g. 1,2, ...13
                this.startAngle = 0; //int, in degrees [°]
                this.endAngle = 0;  //int, in degrees [°]
                this.radius = 0;  //int, in pixels
                this.lineWidth = 1;  //int, in pixels, at least 1px
                this.rotation = 1; //int, in degrees, if negative move counterclockwise, default = 1;
                this.rotateToAngle = 0; //int, in next draw circle, rotate to this angle, default = 0;
                this.counterclockwise = false; //boolean, false is default (oposit of normal clockwise direction)
                this.colorScheme = []; //array, color scheme in RGB values, separated by comma
            }
            
            
            //Constructor of object Circle
            //Each circle has it's own object
            function Circle(properties){
                this.properties = properties; //see function/object Properties for more info
                this.scheme = null; //color scheme
            }
            Circle.prototype.rotate = function(){
                //Rotate canvas
                Circles.ctx.save();
                Circles.ctx.translate(Playground.center_x, Playground.center_y); //move canvas to newer position
                Circles.ctx.rotate(this.properties.rotateToAngle * Math.PI/180); //rotate it, from degree to radian
                Circles.ctx.translate(-Playground.center_x, -Playground.center_y); //move canvas back, so it will be rotated around center
                
                //Draw Circle
                this.draw();

                //Put canvas back (for other circles)
                Circles.ctx.restore();
                
                //Count rotate angle for next frame
                this.properties.rotateToAngle = this.properties.rotateToAngle + this.properties.rotation;
                if(this.properties.rotateToAngle < 0 || this.properties.rotateToAngle > 360) {
                    this.properties.rotateToAngle = Math.abs(360 - Math.abs(this.properties.rotateToAngle));
                }

                return true;
            }
            Circle.prototype.animate = function(){
                this.rotate();
            }
            Circle.prototype.setColorScheme = function(scheme){
                this.scheme = scheme;
                return true;
            }
            //method to set color for each piece
            //this method run only once for each circe
            //TODO rename it and split it!!
            Circle.prototype.countColorScheme = function() {
                
                var all_drawable_pieces = 0;
                //Count number of degrees between start angle and end angle
                if (this.properties.counterclockwise === 0) { //arc is clockwise
                    
                    if( this.properties.startAngle > this.properties.endAngle ) { //we are going through 360°/0°
                        var temp_degree1, temp_degree2;
                        temp_degree1 = 360 - this.properties.startAngle;
                        temp_degree2 = this.properties.endAngle;
                        all_drawable_pieces = temp_degree1 + temp_degree2;
                    } else {
                        all_drawable_pieces = this.properties.endAngle - this.properties.startAngle;
                    }
                    
                } else { //arc is anticlockwise or counterclockwise
                    
                    if( this.properties.startAngle > this.properties.endAngle ) {
                        all_drawable_pieces = this.properties.startAngle - this.properties.endAngle;
                    } else { //we are going through 360°/0°
                        var temp_degree1, temp_degree2;
                        temp_degree1 = this.properties.startAngle;
                        temp_degree2 = 360 - this.properties.endAngle;
                        all_drawable_pieces = temp_degree1 + temp_degree2;
                    }                    
                }
                all_drawable_pieces = all_drawable_pieces - 1;
                
                var temp_scheme = [];
                temp_scheme['begin'] = [];
                temp_scheme['end'] = [];
                
                //TODO: add random choice for begin and end color - take random color from color range!
                
                //Set which color will begin and which end
                var splited_scheme =  this.properties.colorScheme[0].split(',');
                temp_scheme['begin']['r'] = parseInt(splited_scheme[0]);
                temp_scheme['begin']['g'] = parseInt(splited_scheme[1]);
                temp_scheme['begin']['b'] = parseInt(splited_scheme[2]);

                splited_scheme = this.properties.colorScheme[1].split(',');
                temp_scheme['end']['r'] = parseInt(splited_scheme[0]);
                temp_scheme['end']['g'] = parseInt(splited_scheme[1]);
                temp_scheme['end']['b'] = parseInt(splited_scheme[2]);
                
                if(Math.round(Math.random() * 1) === 0) {   //with ratio 50/50 change begin color to end color (or not)
                    splited_scheme = this.properties.colorScheme[1].split(',');
                    temp_scheme['begin']['r'] = parseInt(splited_scheme[0]);
                    temp_scheme['begin']['g'] = parseInt(splited_scheme[1]);
                    temp_scheme['begin']['b'] = parseInt(splited_scheme[2]);

                    splited_scheme = this.properties.colorScheme[0].split(',');
                    temp_scheme['end']['r'] = parseInt(splited_scheme[0]);
                    temp_scheme['end']['g'] = parseInt(splited_scheme[1]);
                    temp_scheme['end']['b'] = parseInt(splited_scheme[2]);
                }

                //ratio between begin begin color and end color and number of drawable pieces
                //(e.g. begin color is 10 (rgb value) and end color is 20 and drawable pieces is 5 so
                //the first piece will have color value 12, next 14, 16, 18 and 20
                var ratio_r = this.countColorRatioAndDirection(temp_scheme['begin']['r'], temp_scheme['end']['r'], all_drawable_pieces);
                var ratio_g = this.countColorRatioAndDirection(temp_scheme['begin']['g'], temp_scheme['end']['g'], all_drawable_pieces);
                var ratio_b = this.countColorRatioAndDirection(temp_scheme['begin']['b'], temp_scheme['end']['b'], all_drawable_pieces);

                //set color for each piece
                var color_scheme = [];
                color_scheme[0] = [];
                //first piece
                color_scheme[0]['rgb'] = 'rgb('+temp_scheme['begin']['r']+','+temp_scheme['begin']['g']+','+temp_scheme['begin']['b']+')';
                color_scheme[0]['radian'] = this.properties.startAngle * Math.PI / 180;
                
                var radian_direction = this.properties.counterclockwise === 1? -1 : 1;
                var angle = this.properties.startAngle;
                for (var i = 1; i <= all_drawable_pieces; i++){
                    angle += radian_direction;
                   
                    color_scheme[i] = [];
                    //other pieces
                    color_scheme[i]['rgb']  = 'rgb('+ Math.round(temp_scheme['begin']['r'] + (ratio_r * i))+','+
                                            +Math.round(temp_scheme['begin']['g'] + (ratio_g * i))+','+
                                            +Math.round(temp_scheme['begin']['b'] + (ratio_b * i))+')';
                   
                    if (angle <= 0) {
                        angle = 359;
                    } else if (angle > 360) {
                        angle = 1;
                    }
                    color_scheme[i]['radian'] = angle * Math.PI/180;
                }
                
                this.setColorScheme(color_scheme);
                return true;
            }
            Circle.prototype.countColorRatioAndDirection = function(begin_color, end_color, degrees){
                
                var ratio = Math.abs(begin_color - end_color) / degrees;
                return begin_color >= end_color ? ratio * -1 : ratio;
                
            }
            //Method for drawing circle
            Circle.prototype.draw = function() {
                
                Circles.ctx.lineWidth = this.properties.lineWidth;

                for (var key in this.scheme) {
                    key = parseInt(key);
            
                    if( typeof(this.scheme[key+1]) == 'undefined') break;

                    // draw a sector
                    Circles.ctx.beginPath();
                    Circles.ctx.arc(
                        Playground.center_x,
                        Playground.center_y,
                        this.properties.radius,
                        typeof(this.scheme[key-1]) === 'undefined'? this.scheme[key]['radian']:this.scheme[key-1]['radian'],
                        this.scheme[key+1]['radian'],
                        this.properties.counterclockwise
                    );
                    
                    //stroke a sector
                    Circles.ctx.strokeStyle = this.scheme[key]['rgb'];
                    Circles.ctx.stroke();
                    Circles.ctx.closePath();
                }
                return true;
            }
            Circle.prototype.init = function(){
                
                this.countColorScheme();
                this.draw();

            }
            
            
            //Circle object
            //Hold reference to all Circle objects
            var Circles = {
                circles_collection: [], //array with all circle objects
                ctx: null, //reference to canvas object

                //collect all circle objects in array, insert circle object
                addCircle: function(circle){
                    this.circles_collection.push(circle);
                    return true;
                },
                //return all existing circle objects in array
                getCircles: function(){
                    return this.circles_collection;
                },
                //create canvas element and hold references to it
                init: function(){

                    var canvas_div = document.createElement('div');

                    var canvas_html = '<canvas id=\"playground_canvas\" width=\"'+Playground.width+'\" height=\"'+Playground.height+'\">'+Init.no_canvas_support+'<\/canvas>';
                    canvas_div.innerHTML = canvas_html;

                    document.getElementById('draw').appendChild(canvas_div);
                    var canvas = document.getElementById('playground_canvas');
                    
                    this.ctx = canvas.getContext('2d');
                },
                //recursion
                findRadius: function(all_circles, min_radius, max_radius, line_width, deep){
                    
                    //Check if we are not too deep in recursion, if yes return false and 'delete' circle (TODO: change line_width and count again)
                    deep++;
                    if(deep === 10) return false;
                    
                    var circle_radius = Math.floor(Math.random() * max_radius) + min_radius;  //'normal' radius
                    
                    var min_line_radius = circle_radius - Math.round(line_width / 2) - 1; //radius - 1/2 line width = min_line_radius - need to check collision with other circles
                    var max_line_radius = circle_radius + Math.round(line_width / 2) + 1; //radius + 1/2 line width = max_line_radius - need to check collision with other circles

                    //If no circle has been set yet, return current radius (= no collision)
                    if(all_circles.length < 1){
                        return circle_radius;
                    }
                    
                    //We have already some circles, need to check if collision or not
                    var collision_radius, collision_min_line_radius, collision_max_line_radius;
                    for(var key in all_circles) {
                        collision_radius = all_circles[key].properties.radius;  //'normal' radius
                        
                        collision_min_line_radius = collision_radius - Math.round(all_circles[key].properties.lineWidth / 2);
                        collision_max_line_radius = collision_radius + Math.round(all_circles[key].properties.lineWidth / 2);

                        //if true, we have collision
                        if(   (max_line_radius >= collision_max_line_radius && min_line_radius < collision_max_line_radius && min_line_radius > collision_min_line_radius)
                            || (max_line_radius <= collision_max_line_radius && max_line_radius >= collision_min_line_radius && min_line_radius < collision_min_line_radius)
                            ){
                            //recursion
                            return this.findRadius(all_circles, min_radius, max_radius, line_width, deep);
                        }
                    }
                    //no collision
                    return circle_radius;
                },
                animate: function(){
                    this.draw();
                },
                draw: function(){
                    //clear canvas
                    this.ctx.clearRect(0, 0, Playground.width, Playground.height);
                    
                    //draw circles
                    for (var key in this.circles_collection) {
                        this.circles_collection[key].animate();
                    }  
                }
            }
            
            
            //Statistics
            var Statistics = {
                frame_count: 0, //number of frames
                html_fps: null, //pointer to DOM to display FPS
                timeout_id: null,
                animate: function(){
                    this.frame_count++;
                },
                resetFrames: function(){
                    this.displayFPS();
                    this.frame_count = 0;
                },
                displayFPS: function() {
                    this.html_fps.innerHTML = this.frame_count;
                },
                init: function(html_fps) {
                    this.html_fps = html_fps;
                },
                start: function() {
                    this.timeout_id = setInterval( 'Statistics.resetFrames()', 1000 );
                },
                stop: function() {
                     clearInterval(this.timeout_id);
                }
            }
            
            
            var Animation = {
                animation_id: null,
                objects_to_animate: null,
                init: function() {
                    // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
                    // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
                    // requestAnimationFrame polyfill by Erik Möller
                    // fixes from Paul Irish and Tino Zijdel
                    (function() {
                        var lastTime = 0;
                        var vendors = ['ms', 'moz', 'webkit', 'o'];
                        for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
                            window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
                            window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] 
                                || window[vendors[x]+'CancelRequestAnimationFrame'];
                        }

                        if (!window.requestAnimationFrame)
                            window.requestAnimationFrame = function(callback, element) {
                                var currTime = new Date().getTime();
                                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                                var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
                                timeToCall);
                                lastTime = currTime + timeToCall;
                                return id;
                            };

                        if (!window.cancelAnimationFrame)
                            window.cancelAnimationFrame = function(id) {
                                clearTimeout(id);
                            };
                    }());
                },
                start: function() {
                
                    if( this.objects_to_animate === 'null') return false;
                
                    //run animations
                    //by: http://paulirish.com/2011/requestanimationframe-for-smart-animating/
                    (function animloop(){
                        Animation.frame_count++;
                        Animation.animate()
                        this.animation_id = window.requestAnimationFrame(animloop);
                    })();
                },
                stop: function() {
                     clearInterval(this.timeout_id);
                },
                setObjToAnimate: function(objects_to_animate){
                    this.objects_to_animate = arguments;
                },
                animate: function(objects_to_animate) {
                    for(key in this.objects_to_animate) {
                        this.objects_to_animate[key].animate();
                    }
                }
            }
            
            
            //Init everything a start
            Init.init();
            
            //]]>
        </script>
    </body>
</html>
